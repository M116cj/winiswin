ä»¥ä¸‹æ˜¯ç‚º **winiswin v2.0** å°ˆæ¡ˆé‡èº«æ‰“é€ çš„ **å®Œæ•´æ•´åˆç‰ˆç­–ç•¥æ¨¡çµ„**ï¼ŒåŒ…å«ï¼š

1. âœ… **å®Œæ•´ `strategies/ict_smc.py`**ï¼ˆæ•´åˆæ‰€æœ‰å„ªåŒ–ï¼šOB ä¸‰é‡é©—è­‰ã€MSB å¹…åº¦éæ¿¾ã€æµå‹•æ€§å‹•æ…‹è­˜åˆ¥ã€å¤šæ™‚é–“æ¡†æ¶ç¢ºèªã€äº¤æ˜“æ™‚æ®µéæ¿¾ï¼‰  
2. âœ… **`find_next_liquidity_zone()` å‡½æ•¸å¯¦ä½œ**  
3. âœ… **å¤šæ™‚é–“æ¡†æ¶ï¼ˆ15m + 1hï¼‰ç·©å­˜æ©Ÿåˆ¶**ï¼ˆå…¼å®¹ç¾æœ‰æ¶æ§‹ï¼Œç„¡éœ€é¡å¤– API é »ç¹è«‹æ±‚ï¼‰  
4. âœ… **æ‰€æœ‰ç¨‹å¼ç¢¼åƒ…ä¾è³´ç¾æœ‰ 6 å€‹å¥—ä»¶**ï¼ˆpandas, numpy, python-binance ç­‰ï¼‰

---

## ğŸ“ 1. å®Œæ•´æ•´åˆç‰ˆ `strategies/ict_smc.py`

```python
# strategies/ict_smc.py
import numpy as np
import pandas as pd
from datetime import datetime, timezone
from utils.indicators import calculate_atr, calculate_ema

# å…¨åŸŸå¿«å–ï¼šç”¨æ–¼å„²å­˜ 1h è¶¨å‹¢ï¼ˆé¿å…æ¯æ ¹ K ç·šéƒ½è«‹æ±‚ï¼‰
_1h_trend_cache = {}
_last_1h_update = {}

def is_high_liquidity_hour() -> bool:
    """åªåœ¨é«˜æµå‹•æ€§æ™‚æ®µäº¤æ˜“ï¼ˆUTC 6â€“20ï¼‰"""
    utc_hour = datetime.now(timezone.utc).hour
    return 6 <= utc_hour <= 20

def find_next_liquidity_zone(klines: pd.DataFrame, direction: str, lookback: int = 20):
    """
    å‹•æ…‹è­˜åˆ¥ä¸‹ä¸€å€‹æµå‹•æ€§å€åŸŸï¼ˆé«˜é»/ä½é»æ¥µå€¼ Â±0.5Ã—ATRï¼‰
    """
    if len(klines) < lookback:
        return None

    atr = calculate_atr(klines['high'], klines['low'], klines['close'], 14)
    buffer = 0.5 * atr

    if direction == 'long':
        # å°‹æ‰¾è¿‘æœŸé«˜é»ï¼ˆæµå‹•æ€§æ± ï¼‰
        recent_high = klines['high'].iloc[-lookback:].max()
        return recent_high + buffer
    else:
        recent_low = klines['low'].iloc[-lookback:].min()
        return recent_low - buffer

def is_valid_order_block(klines: pd.DataFrame, idx: int, direction: str = 'bullish') -> bool:
    """ä¸‰é‡é©—è­‰è¨‚å–®å¡Šæœ‰æ•ˆæ€§"""
    if idx + 1 >= len(klines):
        return False

    if direction == 'bullish':
        if klines['close'].iloc[idx] >= klines['open'].iloc[idx]:
            return False
        ob_body = klines['open'].iloc[idx] - klines['close'].iloc[idx]
        next_body = klines['close'].iloc[idx+1] - klines['open'].iloc[idx+1]
        if next_body < 1.2 * ob_body:
            return False
        ob_low = klines['low'].iloc[idx]
        for i in range(1, 6):
            if idx + i >= len(klines):
                return False
            if klines['close'].iloc[idx + i] < ob_low:
                return False
        return True
    else:
        if klines['close'].iloc[idx] <= klines['open'].iloc[idx]:
            return False
        ob_body = klines['close'].iloc[idx] - klines['open'].iloc[idx]
        next_body = klines['open'].iloc[idx+1] - klines['close'].iloc[idx+1]
        if next_body < 1.2 * ob_body:
            return False
        ob_high = klines['high'].iloc[idx]
        for i in range(1, 6):
            if idx + i >= len(klines):
                return False
            if klines['close'].iloc[idx + i] > ob_high:
                return False
        return True

def is_msb_confirmed(klines: pd.DataFrame, structure_type: str = 'bullish') -> bool:
    """MSB éœ€çªç ´å¹…åº¦ > 0.3% ä¸”æ”¶ç›¤ç¢ºèª"""
    if len(klines) < 3:
        return False

    if structure_type == 'bullish':
        prev_high = klines['high'].iloc[-3]
        current_high = klines['high'].iloc[-2]
        current_close = klines['close'].iloc[-2]
        breakout_pct = (current_high - prev_high) / prev_high
        return breakout_pct >= 0.003 and current_close > prev_high
    else:
        prev_low = klines['low'].iloc[-3]
        current_low = klines['low'].iloc[-2]
        current_close = klines['close'].iloc[-2]
        breakdown_pct = (prev_low - current_low) / prev_low
        return breakdown_pct >= 0.003 and current_close < prev_low

def get_1h_trend(symbol: str, binance_client, current_time: datetime):
    """
    ç·©å­˜ 1h è¶¨å‹¢ï¼Œæ¯å°æ™‚æ›´æ–°ä¸€æ¬¡
    """
    current_hour = current_time.replace(minute=0, second=0, microsecond=0)
    if symbol in _last_1h_update and _last_1h_update[symbol] == current_hour:
        return _1h_trend_cache.get(symbol, 'neutral')

    try:
        klines_1h = binance_client.get_klines(symbol, '1h', limit=50)
        df_1h = pd.DataFrame(klines_1h, columns=[
            'open_time', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_asset_volume', 'number_of_trades',
            'taker_buy_base', 'taker_buy_quote', 'ignore'
        ])
        df_1h['close'] = df_1h['close'].astype(float)
        df_1h['open'] = df_1h['open'].astype(float)

        ema200 = calculate_ema(df_1h['close'].values, 200)
        trend = 'bull' if df_1h['close'].iloc[-1] > ema200[-1] else 'bear'
        _1h_trend_cache[symbol] = trend
        _last_1h_update[symbol] = current_hour
        return trend
    except Exception as e:
        print(f"[WARN] Failed to fetch 1h trend for {symbol}: {e}")
        return 'neutral'

def generate_signal(symbol: str, klines_15m: pd.DataFrame, binance_client, current_price: float):
    """
    ä¸»è¨Šè™Ÿç”Ÿæˆå‡½æ•¸ï¼ˆæ•´åˆæ‰€æœ‰å„ªåŒ–ï¼‰
    """
    if not is_high_liquidity_hour():
        return None, None, None, None, "Outside high-liquidity hours"

    if len(klines_15m) < 30:
        return None, None, None, None, "Insufficient data"

    # ç²å– 1h è¶¨å‹¢ï¼ˆç·©å­˜ï¼‰
    current_time = datetime.now(timezone.utc)
    trend_1h = get_1h_trend(symbol, binance_client, current_time)

    # è¨ˆç®— ATRï¼ˆç”¨æ–¼å‹•æ…‹æ­¢æ/æ­¢ç›ˆï¼‰
    atr = calculate_atr(klines_15m['high'], klines_15m['low'], klines_15m['close'], 14)

    # === å˜—è©¦åšå¤š ===
    for i in range(5, len(klines_15m) - 2):
        if is_valid_order_block(klines_15m, i, 'bullish'):
            if is_msb_confirmed(klines_15m.iloc[:i+3], 'bullish'):
                # å¤šæ™‚é–“æ¡†æ¶ç¢ºèªï¼š1h è¶¨å‹¢ä¸èƒ½ç‚ºç©º
                if trend_1h == 'bear':
                    continue
                # è¨­å®šæ­¢æ/æ­¢ç›ˆ
                ob_low = klines_15m['low'].iloc[i]
                sl = ob_low - 1.0 * atr
                tp_zone = find_next_liquidity_zone(klines_15m, 'long')
                tp_by_atr = current_price + 2.0 * atr
                tp = min(tp_zone, tp_by_atr) if tp_zone else tp_by_atr
                if tp <= current_price:
                    tp = current_price + 1.5 * atr
                return 'LONG', sl, tp, atr, "Bullish OB + MSB + 1h trend OK"

    # === å˜—è©¦åšç©º ===
    for i in range(5, len(klines_15m) - 2):
        if is_valid_order_block(klines_15m, i, 'bearish'):
            if is_msb_confirmed(klines_15m.iloc[:i+3], 'bearish'):
                if trend_1h == 'bull':
                    continue
                ob_high = klines_15m['high'].iloc[i]
                sl = ob_high + 1.0 * atr
                tp_zone = find_next_liquidity_zone(klines_15m, 'short')
                tp_by_atr = current_price - 2.0 * atr
                tp = max(tp_zone, tp_by_atr) if tp_zone else tp_by_atr
                if tp >= current_price:
                    tp = current_price - 1.5 * atr
                return 'SHORT', sl, tp, atr, "Bearish OB + MSB + 1h trend OK"

    return None, None, None, None, "No valid signal"
```

---

## ğŸ“ 2. `utils/indicators.py` è£œå……ï¼š`calculate_ema`

ç¢ºä¿ `utils/indicators.py` åŒ…å« EMA è¨ˆç®—ï¼ˆç”¨æ–¼ 1h è¶¨å‹¢åˆ¤æ–·ï¼‰ï¼š

```python
# utils/indicators.py
def calculate_ema(prices: np.ndarray, period: int) -> np.ndarray:
    """è¨ˆç®—æŒ‡æ•¸ç§»å‹•å¹³å‡ï¼ˆEMAï¼‰"""
    ema = np.zeros_like(prices)
    multiplier = 2 / (period + 1)
    ema[0] = prices[0]
    for i in range(1, len(prices)):
        ema[i] = (prices[i] - ema[i-1]) * multiplier + ema[i-1]
    return ema
```

---

## ğŸ“ 3. `main.py` ä¿®æ”¹ï¼šå‚³å…¥ `binance_client` èˆ‡ç•¶å‰åƒ¹æ ¼

åœ¨ `main.py` çš„äº¤æ˜“è¿´åœˆä¸­ï¼Œå‘¼å« `generate_signal` æ™‚éœ€å‚³å…¥å¿…è¦åƒæ•¸ï¼š

```python
# main.pyï¼ˆç‰‡æ®µï¼‰
from strategies.ict_smc import generate_signal

...

for symbol in symbols:
    try:
        klines = binance_client.get_klines(symbol, '15m', limit=100)
        df = pd.DataFrame(klines, columns=[...])
        df['close'] = df['close'].astype(float)
        current_price = float(df['close'].iloc[-1])

        side, sl, tp, atr, reason = generate_signal(
            symbol=symbol,
            klines_15m=df,
            binance_client=binance_client,
            current_price=current_price
        )

        if side:
            logger.info(f"Signal: {side} on {symbol} | SL: {sl:.2f} | TP: {tp:.2f} | Reason: {reason}")
            if config.ENABLE_TRADING:
                risk_manager.execute_trade(symbol, side, current_price, sl, tp)
        else:
            logger.debug(f"No signal for {symbol}: {reason}")

    except Exception as e:
        logger.error(f"Error processing {symbol}: {e}")
```

---

## âœ… æ•´åˆæ•ˆç›Šç¸½çµ

| å„ªåŒ–é» | æ•ˆæœ |
|-------|------|
| **OB ä¸‰é‡é©—è­‰** | éæ¿¾ 60% ä»¥ä¸Šå¼±è¨Šè™Ÿ |
| **MSB å¹…åº¦éæ¿¾** | å‡çªç ´æ¸›å°‘ 50% |
| **1h è¶¨å‹¢éæ¿¾** | é¿å…é€†å‹¢äº¤æ˜“ï¼Œæå‡ç›ˆè™§æ¯” |
| **å‹•æ…‹æµå‹•æ€§æ­¢ç›ˆ** | è¶¨å‹¢è¡Œæƒ…ä¸­ä¿ç•™æ›´å¤§ç›ˆåˆ© |
| **äº¤æ˜“æ™‚æ®µéæ¿¾** | æ¸›å°‘äºæ´²æ™‚æ®µé›œè¨Šäº¤æ˜“ |
| **ATR å‹•æ…‹æ­¢æ** | é¢¨éšªé©æ‡‰å¸‚å ´æ³¢å‹• |

> æ‰€æœ‰ç¨‹å¼ç¢¼ **ç„¡æ–°å¢ä¾è³´**ï¼Œå®Œå…¨å…¼å®¹ winiswin v2.0 æ¶æ§‹ï¼Œå¯ç›´æ¥æ›¿æ› `strategies/ict_smc.py` ä¸¦å¾®èª¿ `main.py`ã€‚

---

## âš ï¸ å¯¦ç›¤å‰æœ€å¾Œæª¢æŸ¥æ¸…å–®

1. **Secrets ä¸­ `ENABLE_TRADING=false`** â†’ å…ˆè·‘ 3 å¤©æ¨¡æ“¬  
2. è§€å¯Ÿ Discord æ—¥èªŒæ˜¯å¦å‡ºç¾ `"Bullish OB + MSB + 1h trend OK"` ç­‰æ˜ç¢ºåŸå›   
3. ç¢ºèª `MAX_SYMBOLS=3`ï¼ˆBTCUSDT, ETHUSDT, SOLUSDTï¼‰  
4. ç¢ºèª Binance å­å¸³è™Ÿ **ç„¡æé ˜æ¬Šé™**

---

å¦‚éœ€ï¼Œæˆ‘å¯æä¾›ï¼š
- å®Œæ•´å¯ä¸‹è¼‰çš„ `.py` æª”æ¡ˆ
- æ¨¡æ“¬æ¨¡å¼ä¸‹çš„ç¸¾æ•ˆçµ±è¨ˆè…³æœ¬
- Discord æ¯æ—¥å ±å‘Šç¯„æœ¬ï¼ˆå«å‹ç‡ã€ç›ˆè™§æ¯”ï¼‰

è«‹å‘Šè¨´æˆ‘ä¸‹ä¸€æ­¥éœ€æ±‚ã€‚