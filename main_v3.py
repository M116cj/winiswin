"""
Cryptocurrency Trading Bot v3.0 - Modular Architecture

Main orchestrator that coordinates all services.
"""

import asyncio
import logging
from datetime import datetime
import sys

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('trading_bot.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Import configuration
from config import Config

# Import services
from services import DataService, StrategyEngine, ExecutionService, MonitoringService
from services.virtual_position_tracker import VirtualPositionTracker
from binance_client import BinanceClient
from discord_bot import TradingBotNotifier as DiscordBot
from risk_manager import RiskManager
from trade_logger import TradeLogger


class TradingBotV3:
    """
    Main trading bot orchestrator using modular service architecture.
    
    Services:
    - DataService: Market data with caching and rate limiting
    - StrategyEngine: Multi-strategy signal generation
    - ExecutionService: Position management and trade execution
    - MonitoringService: System metrics and alerts
    """
    
    def __init__(self):
        """Initialize trading bot with all services."""
        logger.info("="*70)
        logger.info("Initializing Cryptocurrency Trading Bot v3.2")
        logger.info("="*70)
        logger.info("üöÄ Version 3.2 Features:")
        logger.info("  ‚úÖ Dynamic Margin Sizing (3%-13% based on confidence)")
        logger.info("  ‚úÖ Win-Rate Based Leverage (3-20x based on performance)")
        logger.info("  ‚úÖ Exchange-Level Stop-Loss/Take-Profit Protection")
        logger.info("  ‚úÖ Comprehensive Trade Logging for XGBoost ML")
        logger.info("  ‚úÖ Virtual Position Tracking (Rank 4+ signals)")
        logger.info("="*70)
        
        # Core components (BinanceClient reads from Config automatically)
        self.binance = BinanceClient()
        
        self.risk_manager = RiskManager()
        self.trade_logger = TradeLogger(Config.TRADES_FILE)
        
        # Trading configurationÔºàÂÖàÂÆöÁæ©ÔºåÂõ†ÁÇ∫ÂæåÈù¢ ExecutionService ÈúÄË¶ÅÁî®Ôºâ
        self.symbols = []
        self.timeframe = Config.TIMEFRAME
        self.cycle_interval = 60  # seconds
        
        # Initialize Discord bot (will be started separately)
        self.discord = None
        if Config.DISCORD_BOT_TOKEN:
            try:
                self.discord = DiscordBot(risk_manager=self.risk_manager)
                logger.info("Discord bot initialized")
            except Exception as e:
                logger.error(f"Failed to initialize Discord bot: {e}")
        
        # Initialize services
        self.data_service = DataService(
            binance_client=self.binance,
            batch_size=50  # Concurrent fetch 50 symbols at a time
        )
        
        self.strategy_engine = StrategyEngine(
            risk_manager=self.risk_manager
        )
        
        self.execution_service = ExecutionService(
            binance_client=self.binance,
            risk_manager=self.risk_manager,
            discord_bot=self.discord,
            enable_trading=Config.ENABLE_TRADING,
            trade_logger=self.trade_logger  # üìä ÂÇ≥ÈÅû trade_logger ‰æõ XGBoost Â≠∏Áøí
        )
        
        logger.info(f"‚öôÔ∏è  Trading mode: {'üî¥ LIVE' if Config.ENABLE_TRADING else 'üü° SIMULATION'}")
        
        # Ë®ªÂÜäÂπ≥ÂÄâÂæåÁ´ãÂç≥ÈáçÊñ∞ÊéÉÊèèÂõûË™ø
        self.execution_service.on_position_closed_callback = self.rescan_symbol_immediately
        logger.info("Registered position closed callback for immediate rescan")
        
        # Ë®≠ÁΩÆ‰ø°ËôüÈ©óË≠âÊâÄÈúÄÁöÑÂºïÁî®
        self.execution_service.strategy_engine = self.strategy_engine
        self.execution_service.data_service = self.data_service
        self.execution_service.timeframe = self.timeframe  # ÂÇ≥ÈÅûÊôÇÈñìÊ°ÜÊû∂ÈÖçÁΩÆ
        logger.info(f"Configured dynamic position validation (timeframe: {self.timeframe})")
        
        self.monitoring_service = MonitoringService(
            discord_bot=self.discord
        )
        
        # Initialize Virtual Position Tracker
        self.virtual_tracker = VirtualPositionTracker(
            trade_logger=self.trade_logger,
            risk_manager=self.risk_manager,
            binance_client=self.binance,
            max_virtual_positions=Config.MAX_VIRTUAL_POSITIONS,
            min_confidence=Config.VIRTUAL_MIN_CONFIDENCE,
            max_age_cycles=Config.VIRTUAL_MAX_AGE_CYCLES
        )
        
        # State
        self.is_running = False
        self.cycle_count = 0
        
        logger.info("All services initialized successfully")
    
    async def initialize(self):
        """Initialize trading symbols and verify connections."""
        logger.info("\n" + "="*70)
        logger.info("Initializing Trading Bot")
        logger.info("="*70)
        
        # ÈÅãË°åÂÅ•Â∫∑Ê™¢Êü•ÔºàÂÉÖÂú®ÂØ¶Áõ§Ê®°ÂºèÔºâ
        if Config.ENABLE_TRADING:
            logger.info("üè• ÂØ¶Áõ§Ê®°ÂºèÔºöÈÅãË°åÂïüÂãïÂÅ•Â∫∑Ê™¢Êü•...")
            try:
                from health_check import HealthChecker
                checker = HealthChecker()
                health_ok = await checker.run_all_checks()
                if not health_ok:
                    logger.error("‚ö†Ô∏è  ÂÅ•Â∫∑Ê™¢Êü•Êú™ÂÆåÂÖ®ÈÄöÈÅéÔºå‰ΩÜÁπºÁ∫åÂïüÂãïÔºàË´ãÊ™¢Êü•Ë≠¶ÂëäÔºâ")
            except Exception as e:
                logger.warning(f"ÂÅ•Â∫∑Ê™¢Êü•Âü∑Ë°åÂ§±Êïó: {e}ÔºåÁπºÁ∫åÂïüÂãï")
        
        # Get trading symbols based on mode
        try:
            if Config.SYMBOL_MODE == 'all':
                logger.info("Fetching ALL USDT perpetual contracts...")
                self.symbols = await self.binance.get_usdt_perpetual_symbols()
                logger.info(f"‚úÖ Monitoring {len(self.symbols)} USDT perpetual contracts")
                
            elif Config.SYMBOL_MODE == 'auto':
                logger.info(f"Auto-selecting top {Config.MAX_SYMBOLS} pairs by volume...")
                all_symbols = await self.binance.get_usdt_perpetual_symbols()
                # Future: Sort by volume and take top N
                self.symbols = all_symbols[:Config.MAX_SYMBOLS]
                logger.info(f"‚úÖ Selected {len(self.symbols)} trading pairs")
                
            else:  # static
                self.symbols = Config.STATIC_SYMBOLS
                logger.info(f"‚úÖ Using {len(self.symbols)} static symbols")
            
        except Exception as e:
            logger.error(f"Failed to get trading symbols: {e}")
            self.symbols = Config.STATIC_SYMBOLS
            logger.info(f"Fallback to {len(self.symbols)} static symbols")
        
        # Verify API connections
        await self._verify_connections()
        
        # üîí Âä†Ëºâ‰∏¶‰øùË≠∑ÁèæÊúâÂÄâ‰ΩçÔºàÈáçÂïüÂæåÊÅ¢Âæ©ÂÄâ‰ΩçÁãÄÊÖãÔºâ
        logger.info("\n" + "="*70)
        logger.info("üîí Loading & Protecting Existing Positions from Binance")
        logger.info("="*70)
        
        # Âæû Binance API Âä†ËºâÁúüÂØ¶ÊåÅÂÄâÂà∞ÂÖßÂ≠ò
        loaded_count = await self.execution_service.load_positions_from_binance()
        
        # ÁÇ∫ÈÄô‰∫õÊåÅÂÄâË®≠ÁΩÆ‰∫§ÊòìÊâÄÁ¥öÂà•ÁöÑÊ≠¢Êêç/Ê≠¢Áõà‰øùË≠∑
        if loaded_count > 0:
            await self.execution_service.set_protection_for_existing_positions()
        else:
            logger.info("No existing positions found, skipping protection setup")
        
        logger.info("\n" + "="*70)
        logger.info("‚úÖ Initialization Complete - Bot Ready")
        logger.info("="*70)
        logger.info(f"üìä Monitoring: {len(self.symbols)} symbols")
        logger.info(f"‚è±Ô∏è  Timeframe: {self.timeframe}")
        logger.info(f"üîÑ Cycle interval: {self.cycle_interval}s")
        logger.info(f"üí∞ Account Balance: ${self.risk_manager.account_balance:,.2f} USDT")
        logger.info(f"üìç Max Positions: {self.execution_service.max_positions}")
        logger.info(f"üíµ Capital per Position: ${self.risk_manager.account_balance/3:,.2f} USDT")
        logger.info(f"üìà Trading Mode: {'LIVE TRADING' if Config.ENABLE_TRADING else 'SIMULATION (Paper Trading)'}")
        logger.info("="*70 + "\n")
    
    async def _verify_connections(self):
        """Verify all API connections and load account balance."""
        # Test Binance
        try:
            await self.binance.get_ticker('BTCUSDT')
            self.monitoring_service.update_health('binance_api', 'healthy')
            logger.info("‚úÖ Binance API connection verified")
            
            # Load real account balance
            await self._load_account_balance()
            
        except Exception as e:
            self.monitoring_service.update_health('binance_api', 'unhealthy')
            logger.error(f"‚ùå Binance API connection failed: {e}")
        
        # Test Discord
        if self.discord:
            self.monitoring_service.update_health('discord_api', 'healthy')
            logger.info("‚úÖ Discord bot ready")
        else:
            self.monitoring_service.update_health('discord_api', 'unhealthy')
    
    async def _load_account_balance(self):
        """Load real account balance from Binance and update RiskManager."""
        try:
            logger.info("="*70)
            logger.info("üìä Loading Account Balance from Binance")
            logger.info("="*70)
            
            # Get account balance (using sync methods in executor)
            loop = asyncio.get_event_loop()
            balance_data = await loop.run_in_executor(None, self.binance.get_account_balance)
            
            if not balance_data:
                logger.warning("‚ö†Ô∏è  No balance data received from Binance API")
                logger.info("‚ÑπÔ∏è  Using default balance: $10,000 USDT")
                logger.info("="*70)
                return
            
            # ‚ö†Ô∏è CRITICAL: Futures trading can ONLY use futures wallet USDT
            # Spot and futures wallets are separate - DO NOT combine them
            spot_usdt = 0.0
            futures_usdt = 0.0
            
            # Get USDT from spot account (for reference only)
            if 'USDT' in balance_data:
                spot_usdt = balance_data['USDT'].get('total', 0.0)
                if spot_usdt > 0:
                    logger.info(f"üíº ÁèæË≤®Èå¢ÂåÖ USDT: ${spot_usdt:,.2f} (ÁÑ°Ê≥ïÁî®ÊñºÂêàÁ¥Ñ‰∫§Êòì)")
            
            # Get futures account balance (USDT-M) - THIS IS WHAT MATTERS
            try:
                futures_usdt = await loop.run_in_executor(None, self.binance.get_futures_balance)
                if futures_usdt and futures_usdt > 0:
                    logger.info(f"üìà ÂêàÁ¥ÑÈå¢ÂåÖ USDT: ${futures_usdt:,.2f} ‚úÖ ÂèØÁî®Êñº‰∫§Êòì")
                else:
                    logger.warning(f"‚ö†Ô∏è  ÂêàÁ¥ÑÈå¢ÂåÖÈ§òÈ°çÁÇ∫ $0 - ÁÑ°Ê≥ïÈÄ≤Ë°åÂêàÁ¥Ñ‰∫§ÊòìÔºÅ")
            except Exception as e:
                logger.error(f"‚ùå ÁÑ°Ê≥ïÁç≤ÂèñÂêàÁ¥ÑÈ§òÈ°ç: {e}")
                futures_usdt = 0.0
            
            # Use ONLY futures balance for futures trading
            usable_balance = futures_usdt
            min_required = 15.0  # Minimum $15 per position
            
            if usable_balance > 0:
                logger.info("-"*70)
                logger.info(f"‚úÖ ÂèØÁî®ÂêàÁ¥Ñ‰∫§ÊòìË≥áÈáë: ${usable_balance:,.2f} USDT")
                logger.info("-"*70)
                logger.info(f"üìä Risk Management Configuration:")
                logger.info(f"   ‚Ä¢ Max Positions: 3")
                logger.info(f"   ‚Ä¢ Capital per Position: ${usable_balance/3:,.2f} USDT (33.33%)")
                logger.info(f"   ‚Ä¢ Risk per Trade: {Config.RISK_PER_TRADE_PERCENT}%")
                logger.info(f"   ‚Ä¢ Max Position Size: {Config.MAX_POSITION_SIZE_PERCENT}%")
                
                # Warn if balance is low
                per_position = usable_balance / 3
                if per_position < min_required:
                    logger.warning(f"\n‚ö†Ô∏è  Ë≠¶ÂëäÔºöÊØèÂÄãÂÄâ‰ΩçÂÉÖ ${per_position:,.2f}ÔºåÂèØËÉΩÁÑ°Ê≥ïÈñãÂÄâ")
                    logger.warning(f"   Âª∫Ë≠∞ÊúüË≤®Èå¢ÂåÖËá≥Â∞ë ${min_required * 3:,.0f} USDT")
                
                if spot_usdt > 0:
                    logger.info(f"\nüí° ÊèêÁ§∫ÔºöÁèæË≤®Èå¢ÂåÖÊúâ ${spot_usdt:,.2f} USDT ÁÑ°Ê≥ïÁî®ÊñºÂêàÁ¥Ñ")
                    logger.info(f"   Â¶ÇÈúÄ‰ΩøÁî®ÔºåË´ãÂú® Binance: Ë≥áÁî¢ ‚Üí ÂäÉËΩâ ‚Üí ÁèæË≤®‚ÜíUÊú¨‰ΩçÂêàÁ¥Ñ")
                
                logger.info("="*70)
                
                # Update RiskManager with ONLY futures balance
                self.risk_manager.update_balance(usable_balance)
            else:
                logger.error("\n‚ùå ÂêàÁ¥ÑÈå¢ÂåÖÈ§òÈ°çÁÇ∫ $0 - ÁÑ°Ê≥ïÈÄ≤Ë°åÂêàÁ¥Ñ‰∫§ÊòìÔºÅ")
                if spot_usdt > 0:
                    logger.info(f"\nüí° Ëß£Ê±∫ÊñπÊ°àÔºö")
                    logger.info(f"   1. ÁôªÂÖ• Binance ‚Üí Ë≥áÁî¢ ‚Üí ÂäÉËΩâ")
                    logger.info(f"   2. Âæû„ÄåÁèæË≤®Èå¢ÂåÖ„ÄçÂäÉËΩâÂà∞„ÄåUÊú¨‰ΩçÂêàÁ¥ÑÈå¢ÂåÖ„Äç")
                    logger.info(f"   3. Âª∫Ë≠∞ÂäÉËΩâ ${spot_usdt:,.2f} USDT")
                    logger.info(f"   4. ÈáçÂïüÊ©üÂô®‰∫∫")
                logger.info("\n‚ÑπÔ∏è  ‰ΩøÁî®ÈªòË™çÊ∏¨Ë©¶È§òÈ°ç: $10,000 USDT (ÂÉÖÊ®°Êì¨)")
                logger.info("="*70)
                
        except Exception as e:
            logger.error(f"‚ùå Failed to load account balance: {e}")
            logger.info("‚ÑπÔ∏è  Using default balance: $10,000 USDT")
            logger.info("="*70)
    
    async def rescan_symbol_immediately(self, symbol: str):
        """
        Á´ãÂç≥ÈáçÊñ∞ÊéÉÊèèÂñÆ‰∏Ä‰∫§ÊòìÂ∞ç‰∏¶ÂòóË©¶ÈñãÂÄâ„ÄÇ
        Âú®ÂÄâ‰ΩçÂπ≥ÂÄâÂæåËß∏ÁôºÔºå‰∏çÁ≠âÂæÖ‰∏ã‰∏ÄÂÄãÈÄ±Êúü„ÄÇ
        
        Args:
            symbol: Ë¶ÅÈáçÊñ∞ÊéÉÊèèÁöÑ‰∫§ÊòìÂ∞ç
        """
        try:
            logger.info(f"\n{'='*70}")
            logger.info(f"üîÑ Á´ãÂç≥ÈáçÊñ∞ÊéÉÊèè {symbol} - ÂÄâ‰ΩçÂ∑≤Âπ≥ÂÄâ")
            logger.info(f"{'='*70}")
            
            # Ê™¢Êü•ÊòØÂê¶ÈÇÑÊúâÁ©∫ÈñíÂÄâ‰Ωç
            current_positions = len(self.execution_service.positions)
            available_slots = self.execution_service.max_positions - current_positions
            
            if available_slots <= 0:
                logger.info(f"‚ÑπÔ∏è  ÁÑ°ÂèØÁî®ÂÄâ‰ΩçÊßΩ‰Ωç ({current_positions}/{self.execution_service.max_positions})")
                return
            
            # Áç≤ÂèñË©≤‰∫§ÊòìÂ∞çÁöÑÊúÄÊñ∞Êï∏ÊìöÔºàÂº∑Âà∂Âà∑Êñ∞ÔºåÁπûÈÅéÁ∑©Â≠òÔºâ
            logger.info(f"üì• Áç≤Âèñ {symbol} ÊúÄÊñ∞Êï∏ÊìöÔºàÂº∑Âà∂Âà∑Êñ∞Ôºâ...")
            klines = await self.data_service.fetch_klines(
                symbol=symbol,
                timeframe=self.timeframe,
                limit=200,
                force_refresh=True  # ÁπûÈÅéÁ∑©Â≠òÔºåÁ¢∫‰øùÁç≤ÂèñÊúÄÊñ∞Êï∏Êìö
            )
            
            if klines is None or klines.empty:
                logger.warning(f"‚ö†Ô∏è  ÁÑ°Ê≥ïÁç≤Âèñ {symbol} Êï∏Êìö")
                return
            
            # ÂàÜÊûêË©≤‰∫§ÊòìÂ∞ç
            current_price = float(klines.iloc[-1]['close'])
            logger.info(f"üîç ÂàÜÊûê {symbol} @ {current_price:.4f}...")
            
            symbols_data = {symbol: (klines, current_price)}
            signals = await self.strategy_engine.analyze_batch(symbols_data)
            
            if not signals:
                logger.info(f"‚ÑπÔ∏è  {symbol} Êú™Áî¢ÁîüÊñ∞‰ø°Ëôü")
                return
            
            # Âü∑Ë°å‰ø°Ëôü
            signal = signals[0]
            logger.info(
                f"üéØ ÁôºÁèæÊñ∞‰ø°Ëôü: {signal.action} @ {signal.price:.4f} "
                f"(‰ø°ÂøÉÂ∫¶: {signal.confidence:.1f}%, ROI: {signal.expected_roi:.2f}%)"
            )
            
            success = await self.execution_service.execute_signal(signal)
            
            if success:
                logger.info(f"‚úÖ {symbol} Á´ãÂç≥ÈáçÊñ∞ÈñãÂÄâÊàêÂäü")
                if self.discord:
                    await self.discord.send_notification(
                        f"‚ö° **Âø´ÈÄüÈáçÊñ∞ÈÄ≤Â†¥**\n"
                        f"‰∫§ÊòìÂ∞ç: {symbol}\n"
                        f"ÊñπÂêë: {signal.action}\n"
                        f"ÂÉπÊ†º: {signal.price:.4f}\n"
                        f"‰ø°ÂøÉÂ∫¶: {signal.confidence:.1f}%\n"
                        f"È†êÊúüÊäïÂ†±Áéá: {signal.expected_roi:.2f}%\n"
                        f"_Âπ≥ÂÄâÂæåÁ´ãÂç≥ÈáçÊñ∞ÊéÉÊèè_"
                    )
            else:
                logger.info(f"‚ÑπÔ∏è  {symbol} ÈáçÊñ∞ÈñãÂÄâË¢´ÊãíÁµï")
            
            logger.info(f"{'='*70}\n")
            
        except Exception as e:
            logger.error(f"ÈáçÊñ∞ÊéÉÊèè {symbol} ÊôÇÁôºÁîüÈåØË™§: {e}", exc_info=True)
    
    async def run_cycle(self):
        """Execute one complete trading cycle."""
        self.cycle_count += 1
        cycle_start = asyncio.get_event_loop().time()
        
        logger.info(f"\n{'='*70}")
        logger.info(f"üìä Trading Cycle #{self.cycle_count} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"{'='*70}")
        
        try:
            # Step 1: Fetch market data (concurrent batch fetching)
            logger.info(f"üì• Fetching data for {len(self.symbols)} symbols...")
            fetch_start = asyncio.get_event_loop().time()
            
            klines_data = await self.data_service.fetch_klines_batch(
                symbols=self.symbols,
                timeframe=self.timeframe,
                limit=200
            )
            
            fetch_time = asyncio.get_event_loop().time() - fetch_start
            self.monitoring_service.record_metric('fetch_time_seconds', fetch_time)
            logger.info(f"‚úÖ Fetched data in {fetch_time:.2f}s")
            
            # Step 2: Analyze all symbols and generate signals
            logger.info(f"üîç Analyzing market data...")
            analysis_start = asyncio.get_event_loop().time()
            
            # Prepare data for analysis (ADD TECHNICAL INDICATORS!)
            from utils.indicators import TechnicalIndicators
            
            symbols_data = {}
            for symbol, df in klines_data.items():
                if df is not None and not df.empty:
                    # Ê∑ªÂä†ÊäÄË°ìÊåáÊ®ôÔºàMACD„ÄÅEMA„ÄÅATRÁ≠âÔºâ
                    df_with_indicators = TechnicalIndicators.calculate_all_indicators(df)
                    
                    if df_with_indicators is not None and not df_with_indicators.empty:
                        current_price = float(df_with_indicators.iloc[-1]['close'])
                        symbols_data[symbol] = (df_with_indicators, current_price)
            
            # Run analysis (v2.0: ÂÇ≥ÈÅû binance_client Áî®Êñº 1h Ë∂®Âã¢ÈÅéÊøæ)
            signals = await self.strategy_engine.analyze_batch(symbols_data, binance_client=self.binance)
            
            analysis_time = asyncio.get_event_loop().time() - analysis_start
            self.monitoring_service.record_metric('analysis_time_seconds', analysis_time)
            logger.info(f"‚úÖ Analysis complete in {analysis_time:.2f}s - {len(signals)} signals generated")
            
            # Step 3: Rank and filter signals
            if signals:
                top_signals = self.strategy_engine.rank_signals(
                    signals=signals,
                    mode='confidence',  # or 'roi'
                    limit=self.execution_service.max_positions
                )
                
                logger.info(f"üéØ Top {len(top_signals)} signals selected:")
                for i, signal in enumerate(top_signals, 1):
                    logger.info(
                        f"  {i}. {signal.symbol}: {signal.action} @ {signal.price:.4f} "
                        f"(confidence: {signal.confidence:.1f}%, ROI: {signal.expected_roi:.2f}%)"
                    )
            else:
                top_signals = []
                logger.info("‚ÑπÔ∏è  No signals generated this cycle")
            
            # Step 4: Execute signals (if any positions available)
            current_positions = len(self.execution_service.positions)
            available_slots = self.execution_service.max_positions - current_positions
            
            if available_slots > 0 and top_signals:
                logger.info(f"üíº Executing signals ({available_slots} slots available)...")
                
                for signal in top_signals[:available_slots]:
                    success = await self.execution_service.execute_signal(signal)
            
            # Step 5: Create virtual positions from remaining signals (rank 4+)
            if signals and len(signals) > 3:
                logger.info(f"üî∑ Creating virtual positions from rank 4+ signals...")
                # Sort all signals by confidence (same as top_signals logic)
                sorted_signals = sorted(signals, key=lambda s: s.confidence, reverse=True)
                self.virtual_tracker.create_virtual_positions(sorted_signals, start_rank=4)
            
            # Step 6: Check existing virtual positions
            await self.virtual_tracker.check_virtual_positions(self.data_service)
            
            # Step 7: Monitor existing positions
            if self.execution_service.positions:
                closed = await self.execution_service.monitor_positions()
                if closed:
                    logger.info(f"üîÑ Closed {len(closed)} positions: {', '.join(closed)}")
            
            # Step 8: Cleanup cache
            await self.data_service.cleanup_cache()
            
            # Calculate cycle time
            cycle_time = asyncio.get_event_loop().time() - cycle_start
            self.monitoring_service.record_metric('cycle_time_seconds', cycle_time)
            
            # Log summary
            logger.info(f"\nüìä Cycle Summary:")
            logger.info(f"  ‚è±Ô∏è  Total time: {cycle_time:.2f}s")
            logger.info(f"  üì• Fetch time: {fetch_time:.2f}s")
            logger.info(f"  üîç Analysis time: {analysis_time:.2f}s")
            logger.info(f"  üìä Symbols analyzed: {len(symbols_data)}")
            logger.info(f"  üéØ Signals generated: {len(signals)}")
            logger.info(f"  üíº Active positions: {current_positions}/{self.execution_service.max_positions}")
            logger.info(f"{'='*70}\n")
            
            # Check for alerts
            data_stats = self.data_service.get_stats()
            api_error_rate = data_stats['data_service'].get('failed_fetches', 0) / max(data_stats['data_service'].get('total_fetches', 1), 1)
            
            await self.monitoring_service.check_alerts(
                current_drawdown=0,  # TODO: Calculate from positions
                api_error_rate=api_error_rate,
                scan_time=cycle_time
            )
            
        except Exception as e:
            logger.error(f"Error in trading cycle: {e}", exc_info=True)
            await self.monitoring_service.send_alert(
                f"Trading cycle error: {str(e)}",
                severity='critical'
            )
    
    async def run(self):
        """Main run loop."""
        self.is_running = True
        
        logger.info("\nüöÄ Starting trading bot main loop")
        logger.info("Press Ctrl+C to stop\n")
        
        # Start Discord bot if available
        if self.discord:
            asyncio.create_task(self.discord.start_bot())
            await asyncio.sleep(2)  # Wait for Discord to connect
        
        try:
            while self.is_running:
                await self.run_cycle()
                
                # Wait for next cycle
                logger.info(f"‚è≥ Waiting {self.cycle_interval}s for next cycle...")
                await asyncio.sleep(self.cycle_interval)
                
        except KeyboardInterrupt:
            logger.info("\n‚ö†Ô∏è  Keyboard interrupt received")
        except Exception as e:
            logger.error(f"Fatal error in main loop: {e}", exc_info=True)
        finally:
            await self.shutdown()
    
    async def shutdown(self):
        """Gracefully shutdown the bot."""
        logger.info("\n" + "="*70)
        logger.info("üõë Shutting down trading bot...")
        logger.info("="*70)
        
        self.is_running = False
        
        # Save virtual positions
        logger.info("Saving virtual positions...")
        self.virtual_tracker.save_virtual_positions()
        
        # Close all positions if live trading
        if Config.ENABLE_TRADING and self.execution_service.positions:
            logger.info("Closing all positions...")
            for symbol in list(self.execution_service.positions.keys()):
                try:
                    ticker = await self.binance.get_ticker(symbol)
                    if ticker:
                        price = float(ticker.get('lastPrice', 0))
                        await self.execution_service.close_position(symbol, price, "shutdown")
                except Exception as e:
                    logger.error(f"Error closing {symbol}: {e}")
        
        # Export monitoring data
        self.monitoring_service.export_metrics()
        
        # Log final statistics
        logger.info("\nüìä Final Statistics:")
        stats = self.monitoring_service.get_trading_stats(
            self.data_service,
            self.strategy_engine,
            self.execution_service
        )
        
        for service_name, service_stats in stats.items():
            logger.info(f"\n{service_name}:")
            for key, value in service_stats.items():
                logger.info(f"  {key}: {value}")
        
        logger.info("\n‚úÖ Shutdown complete")
        logger.info("="*70)


async def main():
    """Main entry point."""
    try:
        bot = TradingBotV3()
        await bot.initialize()
        await bot.run()
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        sys.exit(1)


if __name__ == '__main__':
    asyncio.run(main())
